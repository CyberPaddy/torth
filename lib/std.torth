// std.torth - Standard library for Torth
// A collection of common functions

// Include libraries
include "lib/errno.torth"
include "lib/sys.torth"
include "lib/math.torth"

// Common constants
const NULL 0 end

// Memory
const MEMORY_CAPACITY 430080 end  // 420 * 1024 => 420kb
memory file_buf MEMORY_CAPACITY end

// Data types
const bool.size   1 end
const char.size   1 end
const int.size    8 end
const ptr.size    8 end
const str.size    8 end
const uint8.size  1 end

// Temporary memories
memory temp_bool  bool.size   end
memory temp_char  char.size   end
memory temp_int   int.size    end
memory temp_ptr   ptr.size    end
memory temp_str   str.size    end
memory temp_uint8 uint8.size  end

// File descriptors
const stdin  0 end
const stdout 1 end
const stderr 2 end

// Usual file modes
const mode_777 0x1ff end
const mode_755 0x1ed end
const mode_750 0x1e8 end
const mode_700 0x1c0 end
const mode_644 0x1a4 end
const mode_640 0x1a0 end
const mode_600 0x180 end

// Extra intrinsics
function div    int int     -> int              : divmod swap drop end
function mod    int int     -> int              : divmod drop end
function /      int int     -> int              : div end
function %      int int     -> int              : mod end
function ^      int int     -> int              : pow end
function drop2  any any     ->                  : drop drop end
function dup2   any any     -> any any any any  : over over end
function rev    any any any -> any any any      : swap rot end // Reverse the top 3 elements
function rotr   any any any -> any any any      : rot rot end // Reverse rot
function not    bool        -> bool             : True != end
function |      int int     -> int              : or end
function lor    bool bool   -> bool             : int swap int or bool end
function land   bool bool   -> bool             : int swap int and bool end
function ||     bool bool   -> bool             : lor end
function &&     bool bool   -> bool             : land end

// Get user input from stdin
function input -> str :
  // Allocate memory for the user input
  MEMORY_CAPACITY malloc
  MEMORY_CAPACITY over stdin read // Returns the amount of bytes read

  // Remove the newline character from the end
  over swap 1 - ptr+ NULL char swap char.store
end

// Write a string to a file descriptor
// Params: int fd, char *buf, size_t count
// Return: ssize_t written_bytes
function write int ptr int -> int : SYS_write syscall3 end

// Read <count> bytes from a file descriptor
// Params: int fd, char *buf, size_t count
// Return: ssize_t read_bytes
function read int ptr int -> int : SYS_read syscall3 end

// Execute the command referred to by <pathname>
// Params: const char *pathname, char *const argv[], char *const envp[]
// Return: On success, execve does not return, on error -1 is returned
function execve str ptr ptr -> int : SYS_execve syscall3 end

// Exit from the program with a <status> code
// Params: int status
function exit int : SYS_exit syscall1 drop end

// Print a string to a file descriptor
// Params: int fd, char *buf
function fputs int str : swap dup str.len swap rot write drop end

// Allocate read-write memory and return the pointer to the allocated memory
// Params: size_t length
// Return: Pointer to the start of the allocated memory
function malloc int -> ptr :
  // Store the length-parameter in temporary integer
  temp_int int.store

  // mmap ( NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0 );
  0 0
  MAP_ANONYMOUS MAP_PRIVATE |
  PROT_READ PROT_WRITE |
  temp_int int.load // length
  NULL SYS_mmap SYSCALL6 ptr

  // Zero the memory of the temporary integer
  NULL temp_int int.store
end

// Print a string to stdout
function puts  str : stdout fputs end

// Print a string to stderr
function eputs str : stderr fputs end

// Ptr functions
function ptr+       int ptr -> ptr : swap int + ptr end
function ptr++      ptr     ->     : ptr.size ptr+  end
function ptr.load   ptr     -> ptr : LOAD_PTR       end
function ptr.store  ptr ptr -> ptr : STORE_PTR      end

// Bool functions
function bool.load  ptr       -> bool : LOAD_BOOL   end
function bool.store ptr bool  ->      : STORE_BOOL  end

// Char functions
function char.load  ptr       -> char : LOAD_CHAR   end
function char.store ptr char  ->      : STORE_CHAR  end

// Return the lowercase character for the given character
function char.lower char -> char :
  if dup char.is_uppercase do 32 + char endif
end

// Return the uppercase character for the given character
function char.upper char -> char :
  if dup char.is_lowercase do 32 - char endif
end

// Test if character is a number
function char.is_numeric char -> bool :
  if
    dup   '0' <=
    over  '9' >=
    &&
  do True
  else False
  endif swap drop
end

// Test if a character is a lowercase letter
function char.is_lowercase char -> bool :
  if
    dup  'a' <=
    over 'z' >=
    &&
  do True
  else False
  endif swap drop
end

// Test if a character is an uppercase letter
function char.is_uppercase char -> bool :
  if
    dup  'A' <=
    over 'Z' >=
    &&
  do True
  else False
  endif swap drop
end

// Test if a character is a letter
function char.is_letter char -> bool :
  if
    dup  char.is_uppercase
    over char.is_lowercase
    ||
  do True
  else False
  endif swap drop
end

// Test if a character is either a letter or a number
function char.is_alphanumeric char -> bool :
  if
    dup  char.is_letter
    over char.is_numeric
    ||
  do True
  else False
  endif swap drop
end

// Int functions
function int.load     ptr       -> int    : LOAD_INT    end
function int.store    ptr int   ->        : STORE_INT   end
function uint8.load   ptr       -> uint8  : LOAD_UINT8  end
function uint8.store  ptr uint8 ->        : STORE_UINT8 end

// Increment pointed value
function int++ ptr : dup int.load 1 + int.store end

// Get the amount of digits in an integer
// Params: number
// Return: amount_of_digits
// Example: 1234 -> 4
function int.get_digits int -> int :
  // The amount of digits == 1 if the integer is 0
  if dup 0 == do
    drop 1
  else
    0 swap while dup 0 != do
      10 /
      swap 1 + swap
    done drop
  endif
end

// Reverse an integer
// Example: 1234 --> 4321
function int.reverse int -> int :
  0 while over 0 < do
    10 * swap dup 10 % rot +
    swap 10 / swap
  done swap drop
end

// Get a string representation of an integer
memory int_digits int.size end
function itoa int -> str :
  // Store the original integer and the amount of digits
  dup temp_int int.store
  int.get_digits int_digits int.store

  ""  // The string representation of the string
  0   // index
  while dup int_digits int.load > do
    // Get the current power of 10
    // 10 ^ (int_digits - 1 - index)
    int_digits int.load
    1 - over - 10 swap pow

    // Store the remainder of the number / the current power of 10 to temp_int
    temp_int int.load
    swap divmod swap
    temp_int int.store

    // Store the quotient of the number / the current power of 10 to the string representation
    '0' + char
    over 4 nth ptr+ char.store

    // index++
    1 +
  done
  // Insert NULL-byte to the end of the string
  over ptr+ NULL char swap char.store

  // Zero temp_int
  NULL temp_int int.store
end

// String functions
function str.load     ptr       -> str  : LOAD_STR    end
function str.store    ptr str   ->      : STORE_STR   end

// Get the length of a string
// Example: "Test string" -> 11
function str.len str -> int :
  0 while dup2 ptr+ char.load NULL != do
    1 +
  done swap drop
end

// Append a character to the end of a string buffer
// Params: string, character
function str.append str char : dup str.len ptr+ char.store end

// Get the character at a certain index of a string
// Params: index, string
// Return: character_at_index
function str.char_at int str -> char : ptr+ char.load end

// Test if a string is a palindrome (reads the same backward or forward)
function str.is_palindrome str -> bool : dup str.reverse streq end

// Overwrite a string with NULL-bytes
function str.empty str :
  0 while dup2 ptr+ char.load NULL != do
    dup2 ptr+ NULL char swap char.store
    1 +
  done drop2
end

// Get an integer representation of a string
function atoi str -> int :
  // Iterate the string character by character
  0 while dup2 ptr+ char.load NULL != do
    dup2 str.char_at

    // Raise an error if the character is not a number
    if dup char.is_numeric not do
      "[ERROR] atoi function failed:" eputs
      " '" eputs 3 nth eputs "' is not an integer.\n" eputs
      1 exit
    endif

    // Get the numeric representation of an ASCII number
    '0' -

    // Multiply the number from temporary memory by 10
    temp_int int.load 10 *

    // Add the current number and store the result
    + temp_int int.store

    1 +
  done drop2
  // Return the integer
  temp_int int.load

  // Zero the memory of temporary integer
  NULL temp_int int.store
end

// Tests if two strings are equal
memory is_equal bool.size end
function streq str str -> bool :
  True is_equal bool.store // is_equal = True
  0 // index
  // while index < len(str1)
  while dup2 swap str.len > do
    if // str1[index] != str2[index]
      dup2            ptr+ char.load
      over 5 nth swap ptr+ char.load
      !=
    do
      False is_equal bool.store // is_equal = False
      break
    endif
    1 +
  done

  if dup 4 nth swap ptr+ char.load NULL != do
    False is_equal bool.store // is_equal = False
  endif
  drop drop drop // Drop strings and index

  // return is_equal
  is_equal bool.load
end

// Reverse a string
memory reversed_str MEMORY_CAPACITY end
function str.reverse str -> str :
  reversed_str str.empty
  dup str.len // index
  while 0 over > do
    1 -
    dup2 ptr+ char.load // str[index]

    // reversed_str[index + 1 - str.len] = str[index]
    over 1 + 4 nth str.len swap - reversed_str swap ptr+ char.store
  done drop2
  reversed_str // Return reversed string
end

// Open a file with open-syscall
// Params: int oflag, const char *path
// Return: fd
function open_file int str -> int :
  over SYS_open syscall2

  if    dup ENOENT  ==  do swap "File '" eputs eputs "' does not exist.\n" eputs 1 exit
  elif  dup EACCESS ==  do swap "Cannot open file '" eputs eputs "': Permission denied.\n" eputs 1 exit
  elif  dup 0 > do
    swap "Error occurred while opening the file '" eputs eputs "'.\nError code: " eputs dup print 1 exit
  else swap drop // Drop the file name
  endif
end

// Read a file to a file buffer (file_buf)
// Params: const char *pathname
// Return: ssize_t read_bytes
function read_file str -> int :
  O_RDONLY open_file
  MEMORY_CAPACITY file_buf rot read
end

// Create a file
// Params: const char *pathname, mode_t mode
function touch_file str int :
  SYS_creat syscall2
end

// Write a string to a file
// Params: const char *filename, mode_t mode, const void *buf
// Return: ssize_t written_bytes
function write_file str int str -> int :
  touch_file
  over dup str.len // size_t count
  swap rot SYS_write syscall3
end

// Print file contents to stdout
// Params: const char *pathname
// Return: ssize_t written_bytes
function print_file str -> int :
  read_file
  file_buf stdout write "\n" puts
end
