include "lib/errno.torth"
include "lib/sys.torth"
include "lib/math.torth"
const NULL 0 end

// Memory
const MEMORY_CAPACITY 430080 end  // 420 * 1024 => 420kb
memory file_buf MEMORY_CAPACITY end

// Data types
const bool.size   1 end
const char.size   1 end
const int.size    8 end
const ptr.size    8 end
const str.size    8 end
const uint8.size  1 end

// Temporary memories
memory bool.temp  bool.size   end
memory char.temp  char.size   end
memory int.temp   int.size    end
memory uint8.temp uint8.size  end

// File descriptors
const stdin  0 end
const stdout 1 end
const stderr 2 end

// Usual file modes
const mode_777 0x1ff end
const mode_755 0x1ed end
const mode_750 0x1e8 end
const mode_700 0x1c0 end
const mode_644 0x1a4 end
const mode_640 0x1a0 end
const mode_600 0x180 end

// Extra intrinsics
function div    int int     -> int              : divmod swap drop end
function mod    int int     -> int              : divmod drop end
function /      int int     -> int              : div end
function %      int int     -> int              : mod end
function ^      int int     -> int              : pow end
function drop2  any any     ->                  : drop drop end
function dup2   any any     -> any any any any  : over over end
function rev    any any any -> any any any      : swap rot end // Reverse the top 3 elements
function rotr   any any any -> any any any      : rot rot end // Reverse rot
function not    bool        -> bool             : True != end
function |      int         -> int              : or end
function lor    bool bool   -> bool             : int swap int or bool end
function land   bool bool   -> bool             : int swap int and bool end
function ||     bool bool   -> bool             : lor end
function &&     bool bool   -> bool             : land end

// int fd, char *buf, size_t count
function write int ptr int -> int : SYS_write syscall3 end
// int fd, char *buf, size_t count
function read int ptr int -> int : SYS_read syscall3 end
// const char *pathname, char *const argv[], char *const envp[]
function execve str ptr ptr -> int : SYS_execve syscall3 end
// int status
function exit int -> : SYS_exit syscall1 drop end

// int fd, char *buf
function fputs int str  -> : swap dup str.len swap rot write drop end
function puts  str      -> : stdout fputs end
function eputs str      -> : stderr fputs end

// Ptr functions
function int++  ptr     ->      : dup int.load 1 + int.store end  // Increment pointed value
function ptr+   int ptr -> ptr  : swap int + ptr end
function ptr++  ptr     ->      : ptr.size ptr+ end

// Bool functions
function bool.load  ptr       -> bool : LOAD_BOOL   end
function bool.store ptr bool  ->      : STORE_BOOL  end

// Char functions
function char.load  ptr       -> char : LOAD_CHAR   end
function char.store ptr char  ->      : STORE_CHAR  end

function char.lower   char -> char :
  if
    dup 'A' <=
    over 'Z' >=
    &&
  do
    32 + char
  endif
end

function char.upper char -> char :
  if dup 'a' <= do
    if dup 'z' >= do
      32 - char
    endif
  endif
end

function char.is_numeric char -> bool :
  if
    dup   '0' <=
    over  '9' >=
    &&
  do
    True
  else
    False
  endif swap drop
end

function char.is_alphanumeric char -> bool :
  if
    dup   'z' <
    over  '0' > lor
    over  '9' <
    3 nth 'A' > land lor
    over  'Z' <
    3 nth 'a' > land lor
  do
    False
  else
    True
  endif swap drop
end

// Int functions
function int.load     ptr       -> int    : LOAD_INT    end
function int.store    ptr int   ->        : STORE_INT   end
function uint8.load   ptr       -> uint8  : LOAD_UINT8  end
function uint8.store  ptr uint8 ->        : STORE_UINT8 end
function int.get_digits int -> int :
  // The amount of digits == 1 if the integer is 0
  if dup 0 == do
    drop 1
  else
    0 swap while dup 0 != do
      10 /
      swap 1 + swap
    done drop
  endif
end

function int.reverse int -> int :
  0 while over 0 < do
    10 * swap dup 10 % rot +
    swap 10 / swap
  done swap drop
end

memory int_digits int.size end
function itoa int -> str :
  // Store the original integer and the amount of digits
  dup int.temp int.store
  int.get_digits int_digits int.store

  ""  // The string representation of the string
  0   // index
  while dup int_digits int.load > do
    // Get the current power of 10
    // 10 ^ (int_digits - 1 - index)
    int_digits int.load
    1 - over - 10 swap pow

    // Store the remainder of the number / the current power of 10 to int.temp
    int.temp int.load
    swap divmod swap
    int.temp int.store

    // Store the quotient of the number / the current power of 10 to the string representation
    '0' + char
    over 4 nth ptr+ char.store

    // index++
    1 +
  done
  // Insert NULL-byte to the end of the string
  over ptr+ NULL char swap char.store

  // Zero int.temp
  NULL int.temp int.store
end

// Str functions
function str.load     ptr       -> str  : LOAD_STR    end
function str.store    ptr str   ->      : STORE_STR   end
function str.len str -> int :
  0 while dup2 ptr+ char.load NULL != do
    1 +
  done swap drop
end

function str.append         str char  ->      : dup str.len ptr+ char.store end
function str.char_at        int str   -> char : ptr+ char.load end
function str.is_palindrome  str       -> bool : dup str.reverse streq end

function str.empty str -> :
  0 while dup2 ptr+ char.load NULL != do
    dup2 ptr+ NULL char swap char.store
    1 +
  done drop2
end

// Return integer representation of a string
function atoi str -> int :
  // Iterate the string character by character
  0 while dup2 ptr+ char.load NULL != do
    dup2 str.char_at

    // Raise an error if the character is not a number
    if dup char.is_numeric not do
      "[ERROR] atoi function failed:" eputs
      " '" eputs 3 nth eputs "' is not an integer.\n" eputs
      1 exit
    endif

    // Get the numeric representation of an ASCII number
    '0' -

    // Multiply the number from temporary memory by 10
    int.temp int.load 10 *

    // Add the current number and store the result
    + int.temp int.store

    1 +
  done drop2
  // Return the integer
  int.temp int.load

  // Zero the memory of temporary integer
  NULL int.temp int.store
end

memory is_equal bool.size end
function streq str str -> bool :
  True is_equal bool.store // is_equal = True
  0 // index
  // while index < len(str1)
  while dup2 swap str.len > do
    if // str1[index] != str2[index]
      dup2            ptr+ char.load
      over 5 nth swap ptr+ char.load
      !=
    do
      False is_equal bool.store // is_equal = False
      break
    endif
    1 +
  done

  if dup 4 nth swap ptr+ char.load NULL != do
    False is_equal bool.store // is_equal = False
  endif
  drop drop drop // Drop strings and index

  // return is_equal
  is_equal bool.load
end

memory reversed_str MEMORY_CAPACITY end
function str.reverse str -> str :
  reversed_str str.empty
  dup str.len // index
  while 0 over > do
    1 -
    dup2 ptr+ char.load // str[index]

    // reversed_str[index + 1 - str.len] = str[index]
    over 1 + 4 nth str.len swap - reversed_str swap ptr+ char.store
  done drop2
  reversed_str // Return reversed string
end

// Params:  int oflag, const char *path
// Returns: fd
function open_file int str -> int :
  over SYS_open syscall2

  if    dup ENOENT  ==  do swap "File '" eputs eputs "' does not exist.\n" eputs 1 exit
  elif  dup EACCESS ==  do swap "Cannot open file '" eputs eputs "': Permission denied.\n" eputs 1 exit
  elif  dup 0 > do
    swap "Error occurred while opening the file '" eputs eputs "'.\nError code: " eputs dup print 1 exit
  else swap drop // Drop the file name
  endif
end

// Params:  const char *pathname
// Returns: the number of bytes read
function read_file str -> int :
  O_RDONLY open_file
  MEMORY_CAPACITY file_buf rot read
end

// Params:  const char *pathname, mode_t mode
function touch_file str int -> :
  SYS_creat syscall2
end

// Params:  const char *filename, const void *buf
// Returns: ssize_t written_bytes
function write_file str str -> int :
  mode_644 swap touch_file
  over dup str.len // size_t count
  swap rot SYS_write syscall3
end

// Params:  const char *pathname
// Returns: the number of bytes written
function print_file str -> int :
  read_file
  file_buf stdout write "\n" puts
end
