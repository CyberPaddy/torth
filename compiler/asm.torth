include "std"
include "compiler/utils"
include "compiler/class/Op"

function initialize_asm -> str :
  "compiler/templates/torth_template.asm" read_file
end

// Get Assembly for certain Op
// Params: Pointer to Op (PTR)
// Return: Assembly
function get_op_asm ptr -> str :
  if dup Op.get_type OpType.PUSH_BOOL == do
    get_push_bool_asm
  elif dup Op.get_type OpType.PUSH_CHAR == do
    get_push_char_asm
  elif dup Op.get_type OpType.PUSH_INT == do
    get_push_int_asm
  elif dup Op.get_type OpType.INTRINSIC == do
    // Get Operand's Token.value
    dup Op.get_token Token.get_value str.upper
    if dup "AND" streq do
      get_and_asm
    elif dup "PLUS" streq do
      get_plus_asm
    elif dup "PRINT" streq do
      get_print_asm
    else
      dup "" swap NotImplementedError
    endif swap drop
  else
    dup NotImplementedError
    ""
  endif swap drop
end

function get_push_bool_asm -> str :
  "PUSH_BOOL is not implemented yet\n" NotImplementedError
  ""
end

function get_push_char_asm -> str :
  "PUSH_CHAR is not implemented yet\n" NotImplementedError
  ""
end

function get_push_int_asm -> str :
  "  mov rax, 3\n"
  "  push rax\n"      str.cat
end

// AND performs bitwise-AND operation to two integers
// Params: None
// Return: Assembly
function get_and_asm -> str :
  "AND is not implemented yet\n" NotImplementedError
  ""
end

// Pop two integers from the stack and push the sum of the two values
// Params: None
// Return: Assembly
function get_plus_asm -> str :
  "  pop rbx\n"
  "  pop rax\n"       str.cat
  "  add rax, rbx\n"  str.cat
  "  push rax\n"      str.cat
end

// Pop an integer from the stack and print the value of it to the stdout
// Params: None
// Return: Assembly
function get_print_asm -> str :
  "  pop rdi\n"
  "  call print\n"    str.cat
end

// Generate assembly code for NASM
// Params: Pointer to Program (PTR)
// Return: Intel x86_64 Assembly for NASM (STR)
memory op_asm str.size end
function generate_asm ptr -> str :
  "" op_asm str.store
  initialize_asm swap

  // Generate assembly for each Op in Program
  0 while dup Program.len int.load > do
    // Get the current Op
    dup2 Program.op_at

    // Print Op
    dup Op.print "\n" puts

    // Concatenate Op's Assembly to op_asm
    get_op_asm op_asm str.load swap str.cat
    op_asm str.store
    1 +
  done drop2 "\n" puts

  // Print generated Assembly
  "Generated Assembly for the Program:\n" puts
  op_asm str.load puts
end
