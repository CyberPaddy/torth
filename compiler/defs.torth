// Keywords
const Keyword.BREAK         0  end
const Keyword.CONST         1  end
const Keyword.DO            2  end
const Keyword.DONE          3  end
const Keyword.ELIF          4  end
const Keyword.ELSE          5  end
const Keyword.END           6  end
const Keyword.ENDIF         7  end
const Keyword.FUNCTION      8  end
const Keyword.IF            9  end
const Keyword.MEMORY        10 end
const Keyword.WHILE         11 end

// Intrinsics
const Intrinsic.AND         0  end
const Intrinsic.ARGC        1  end
const Intrinsic.ARGV        2  end
const Intrinsic.DIV         3  end
const Intrinsic.DROP        4  end
const Intrinsic.DUP         5  end
const Intrinsic.ENVP        6  end
const Intrinsic.EQ          7  end
const Intrinsic.GE          8  end
const Intrinsic.GT          9  end
const Intrinsic.HERE        10 end
const Intrinsic.INPUT       11 end
const Intrinsic.LE          12 end
const Intrinsic.LOAD_BYTE   13 end
const Intrinsic.LOAD_QWORD  14 end
const Intrinsic.LT          15 end
const Intrinsic.MINUS       16 end
const Intrinsic.MOD         17 end
const Intrinsic.MUL         18 end
const Intrinsic.NE          19 end
const Intrinsic.NOT         20 end
const Intrinsic.NTH         21 end
const Intrinsic.OR          22 end
const Intrinsic.OVER        23 end
const Intrinsic.PLUS        24 end
const Intrinsic.PRINT       25 end
const Intrinsic.PUTS        26 end
const Intrinsic.ROT         27 end
const Intrinsic.STORE_BYTE  28 end
const Intrinsic.STORE_QWORD 29 end
const Intrinsic.SWAP        30 end
const Intrinsic.SWAP2       31 end
const Intrinsic.SYSCALL0    32 end
const Intrinsic.SYSCALL1    33 end
const Intrinsic.SYSCALL2    34 end
const Intrinsic.SYSCALL3    35 end
const Intrinsic.SYSCALL4    36 end
const Intrinsic.SYSCALL5    37 end
const Intrinsic.SYSCALL6    38 end

// Operand types
const OpType.BREAK          0  end
const OpType.DO             1  end
const OpType.DONE           2  end
const OpType.ELIF           3  end
const OpType.ELSE           4  end
const OpType.END            5  end
const OpType.ENDIF          6  end
const OpType.IF             7  end
const OpType.INTRINSIC      8  end
const OpType.PUSH_ARRAY     9  end
const OpType.PUSH_CHAR      10 end
const OpType.PUSH_HEX       11 end
const OpType.PUSH_INT       12 end
const OpType.PUSH_PTR       13 end
const OpType.PUSH_STR       14 end
const OpType.WHILE          15 end

// Token types
const TokenType.ARRAY       0 end
const TokenType.BOOL        1 end
const TokenType.CHAR        2 end
const TokenType.HEX         3 end
const TokenType.INT         4 end
const TokenType.KEYWORD     5 end
const TokenType.PTR         6 end
const TokenType.STR         7 end
const TokenType.WORD        8 end

// Tuple[str, int, int] # Source file name, row, column
const Location.size  24 end
memory location Location.size end

// Location(file_name, row, column)
function Location.load str int int -> :
  location
  dup rot swap store_QWORD ptr++  // file_name
  dup rot swap store_QWORD ptr++  // row
  dup rot swap store_QWORD drop   // column
end

// Tuple[str, str, Location]  # Name, str(size), Location
const Memory.size 40 end

// @dataclass
// class Constant:
//    name: str
//    value: str
//    location: Location
const Constant.size     40 end
const Constant.name     8  end
const Constant.value    8  end
const Constant.location 8  end

// @dataclass
// class Token:
//     value: str
//     type: TokenType
//     location: Location
const Token.size     40 end
const Token.value    8  end
const Token.type     8  end
const Token.location 8  end

// Pointer to pointer of Tokens
memory tokens MEMORY_CAPACITY end
memory token  Token.size      end

// Token(value, TokenType, Location)
function Token.load str int ptr -> :
  token
  dup rot swap store_QWORD ptr++  // value
  dup rot swap store_QWORD ptr++  // TokenType
  dup rot swap store_QWORD drop   // Location
end

function Token.getType ptr -> str :
  ptr.size + load_BYTE

  if dup TokenType.ARRAY == do
    "TokenType.ARRAY"
  elif dup TokenType.BOOL == do
    "TokenType.BOOL"
  elif dup TokenType.CHAR == do
    "TokenType.CHAR"
  elif dup TokenType.HEX == do
    "TokenType.HEX"
  elif dup TokenType.INT == do
    "TokenType.INT"
  elif dup TokenType.KEYWORD == do
    "TokenType.KEYWORD"
  elif dup TokenType.PTR == do
    "TokenType.PTR"
  elif dup TokenType.STR == do
    "TokenType.STR"
  elif dup TokenType.WORD == do
    "TokenType.WORD"
  endif
  swap drop // Drop TokenType
end

function Token.getFile ptr -> str :
  dup ptr.size 2 * + load_QWORD load_QWORD
end

function Token.getRow ptr -> str :
  dup ptr.size 2 * + load_QWORD ptr.size + load_QWORD
end

function Token.getColumn ptr -> str :
  dup ptr.size 2 * + load_QWORD ptr.size 2 * + load_QWORD
end

function Token.output ptr -> :
  dup "Type     => " puts Token.getType puts "\n" puts
  dup "Location => File: " puts Token.getFile puts
  ", Row: " puts Token.getRow print ", Column: " puts Token.getColumn print "\n" puts
  drop
end

function Token.print ptr -> :
  dup "Token    => " puts load_QWORD print "\n" puts
  Token.output
end

function Token.puts ptr -> :
  dup "Token    => " puts load_QWORD puts "\n" puts
  Token.output
end

// # param types, return types
// Signature   = Tuple[List[str], List[str]]
const Signature 16 end

// @dataclass
// class Function:
//     name: str
//     signature: Signature
//     tokens: List[Token]
const Function.size       24 end
const Function.name       8  end
const Function.signature  8  end
const Function.tokens     8  end

// @dataclass
// class Op:
//     id: int
//     type: OpType
//     token: Token
const Op.size   24 end
const Op.id     8  end
const Op.type   8  end
const Op.token  8  end

memory Program ptr.size end